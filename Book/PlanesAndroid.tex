\section{ PlanesAndroid }

\subsection { Navigation }

The Android App is built around the so-called Drawer Navigation. This kind of navigation is based on a so-called Hamburger button which in case of the Planes App is displayed in the top left corner of the screen. Tapping on the button displays a list possible destinations in the application. These depend on whether the app is played in the Single Player or Multiplayer Mode. 

In the case of the Single Player App we have:
\begin{itemize}
\item Game
\item Videos
\item Settings
\item Info
\end{itemize}

For the Multiplayer App more screens are available:

\begin{itemize}
	\item Game
	\item Connect to Game
	\item Game Statistics
	\item Login
	\item Logout
	\item Register
	\item Delete User
	\item Videos
	\item Settings
	\item Info
\end{itemize}

When a screen is selected, a Fragment of the Fragment Class corresponding to the screen is loaded into the main layout of the application. The XML layout of the application is shown in \ref{drawer_layout}.

To exemplify how a new screen is loaded onto the screen I show the following function ( \ref{start_norobot_fragment}).

\begin{lstlisting} [caption = {Switch Screen Example},label=start_norobot_fragment]
	fun startNoRobotFragment(regResp : RegistrationResponse) {
		
		mSelectedItem = R.id.nav_norobot  
		
		val newFragment = NoRobotFragment()
		val bundle = Bundle()
		bundle.putString("norobot/requestid", regResp.m_Id)
		bundle.putString("norobot/question", regResp.m_Question)
		val images =  arrayOf(regResp.m_ImageId_1, regResp.m_ImageId_2, regResp.m_ImageId_3, regResp.m_ImageId_4, regResp.m_ImageId_5,
		regResp.m_ImageId_6, regResp.m_ImageId_7, regResp.m_ImageId_8, regResp.m_ImageId_9)
		bundle.putSerializable("norobot/images", images)
		val selection = arrayOf(false, false, false, false, false, false, false, false, false)
		bundle.putSerializable("norobot/selection", selection)
		
		newFragment.arguments = bundle
		
		supportFragmentManager.beginTransaction()
		.replace(R.id.main_content, newFragment, ApplicationScreens.NoRobot.toString())
		.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_FADE)
		.addToBackStack("FromRegister")
		.commit()
		
	}
	
\end{lstlisting}

This code shows the preparation for the start of the fragment called NoRobotFragment, which is the validation window to determine that the user is human. In the variable bundle the parameters that are to be given to the fragment are prepared. The actual switch of the screen is the call supportFragmentManager.beginTransaction(). Specifying R.id.main\_content defines where in the Drawer Layout should the new screen be displayed. 

\subsection {Info Screen} \label {info_screen}

The Info screen is implemented in the AboutFragment class. It makes use of a RecyclerView which is a type of ListView optimized for large number of elements.

The RecyclerView displays a few items each of them having a title, a content text as well as a button. The basis data model class is AboutModel.

\begin{lstlisting}
	class AboutModel(title: String,
	 text: String, buttonPresent: Boolean,
	  textButton: String, linkButton: String) {
		
		private var m_Title: String
		private var m_Text: String
		private var m_ButtonPresent: Boolean
		private var m_TextButton: String
		private var m_LinkButton: String
		
		init {
			m_Title = title
			m_Text = text
			m_ButtonPresent = buttonPresent
			m_TextButton = textButton
			m_LinkButton = linkButton
		}
		
		fun getTitle(): String {
			return m_Title
		}
		
		fun getText(): String {
			return m_Text
		}
		
		fun getTextButton(): String {
			return m_TextButton
		}
		
		fun getLinkButton(): String {
			return m_LinkButton
		}
	}
\end{lstlisting}

Using this model a data repository with text information is constructed as follows:

\begin{lstlisting}
	private fun prepareSectionsList() {
		var version_section = AboutModel("Version", "Software version is unknown", false, "Empty", "Empty")
		
		if (m_Version != null)
		version_section = AboutModel(getString(R.string.software_version_title),
		getString(R.string.software_version) + " " + m_Version, false, "Empty", "Empty")
		val software_section = AboutModel(getString(R.string.credits_software_title),
		getString(R.string.credits_software_content), true, getString(R.string.credits_software_button),
		"https://www.github.com/xxxcucus/planes")
		val graphics_section = AboutModel(getString(R.string.credits_graphics_title),
		getString(R.string.credits_graphics_content1), true, getString(R.string.credits_graphics_button),
		"https://axa951.wixsite.com/portfolio")
		
		val otherContributionText = """
		${getString(R.string.credits_othercontributions_1)}
		${getString(R.string.credits_othercontributions_2)}
		${getString(R.string.credits_othercontributions_3)}
		""".trimIndent()
		val others_section = AboutModel(getString(R.string.credits_othercontributions_title),
		otherContributionText, false, "Empty", "Empty")
		val website_section = AboutModel(getString(R.string.credits_website_title), getString(R.string.credits_website), true,
		getString(R.string.credits_website_button), "https://xxxcucus.github.io/planes/")
		val tools_section = AboutModel(getString(R.string.credits_tools_title),
		getString(R.string.credits_tools), false, "Empty", "Empty")
		
		m_SectionsList = arrayListOf(version_section, software_section, graphics_section, others_section, website_section, tools_section)
		m_AboutAdapter = AboutAdapter(m_SectionsList)
		m_AboutAdapter.notifyDataSetChanged()
	}
\end{lstlisting}

Each item in the RecyclerView is displayed according to a layout which can be of two types: with button:

\begin{lstlisting} [caption = {Layout with button for InfoScreen},label=layout_button_info_screen]
	<?xml version="1.0" encoding="utf-8"?>
	<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
	android:orientation="vertical"
	android:layout_width="wrap_content"
	android:layout_height="wrap_content"
	android:background="?planesBackgroundEndColor">
	
	<TextView
	android:id="@+id/about_section_title"
	android:layout_width="wrap_content"
	android:layout_height="wrap_content"
	android:layout_margin="10dip"
	android:textSize="20sp"
	android:textStyle="bold"
	style="@style/CustomTextViewStyle"
	android:text="@string/help"/>
	<TextView
	android:id="@+id/about_section_text"
	android:layout_width="wrap_content"
	android:layout_height="wrap_content"
	android:layout_margin="10dip"
	android:layout_below="@+id/about_section_title"
	style="@style/CustomTextViewStyle"
	android:textSize="15sp"/>
	
	<Button
	android:id="@+id/about_section_button"
	android:layout_width="wrap_content"
	android:layout_height="wrap_content"
	android:textSize="15sp"
	android:layout_alignParentRight="true"
	android:layout_margin="10dip"
	style="@style/ButtonColor"
	android:text="@string/popup_help_button_text"
	android:layout_below="@+id/about_section_text"
	android:gravity="right"/>
	
	</RelativeLayout>
\end{lstlisting}

or without button:

\begin{lstlisting}  [caption = {Layout without button for InfoScreen},label=layout_with_button_info_screen]
	<?xml version="1.0" encoding="utf-8"?>
	<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
	android:orientation="vertical"
	android:layout_width="match_parent"
	android:layout_height="wrap_content"
	android:background="?planesBackgroundEndColor">
	
	<TextView
	android:id="@+id/about_section_title"
	android:layout_width="wrap_content"
	android:layout_height="wrap_content"
	android:layout_margin="10dip"
	android:textSize="20sp"
	android:textStyle="bold"
	style="@style/CustomTextViewStyle"
	android:text="@string/help"/>
	<TextView
	android:id="@+id/about_section_text"
	android:layout_width="wrap_content"
	android:layout_height="wrap_content"
	android:layout_margin="10dip"
	android:layout_below="@+id/about_section_title"
	style="@style/CustomTextViewStyle"
	android:textSize="15sp"/>
	</RelativeLayout>
\end{lstlisting}

Finally to bind the data with the RecvclerView display a so called Adapter class is needed:

\begin{lstlisting}
	class AboutAdapter(aboutSectionsList: List<AboutModel>) : RecyclerView.Adapter<RecyclerView.ViewHolder>() {
		private val m_SectionsList: List<AboutModel> = aboutSectionsList
		
		
		inner class MyViewHolderWithButton(view: View, context: Context) : RecyclerView.ViewHolder(view) {
			var m_Title: TextView = view.findViewById(R.id.about_section_title)
			var m_Text: TextView = view.findViewById(R.id.about_section_text)
			var m_Button: Button = view.findViewById(R.id.about_section_button)
			private var m_ButtonLink: String = ""
			var m_Context: Context = context
			
			init {
				m_Button.setOnClickListener { Tools.openLink(m_Context, m_ButtonLink) }
			}
			
			fun setButtonLink(link: String) {
				m_ButtonLink = link
			}
		}
		
		inner class MyViewHolderWithoutButton(view: View) : RecyclerView.ViewHolder(view) {
			var m_Title: TextView = view.findViewById(R.id.about_section_title)
			var m_Text: TextView = view.findViewById(R.id.about_section_text)
		}
		
		override fun getItemViewType(position: Int): Int {
			if (position == 1 || position == 2 || position == 4)
			return 0
			return 1
		}
		
		override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {
			val itemView: View = if (viewType == 0)
			LayoutInflater.from(parent.context).inflate(R.layout.aboutlayout, parent, false)
			else
			LayoutInflater.from(parent.context).inflate(R.layout.aboutlayout1, parent, false)
			
			return when (viewType) {
				0 -> MyViewHolderWithButton(itemView, parent.context)
				else -> MyViewHolderWithoutButton(itemView)
			}
		}
		
		override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {
			val section: AboutModel = m_SectionsList[position]
			
			when(holder.itemViewType) {
				0 -> {
					val holderwithButton = holder as MyViewHolderWithButton
					holderwithButton.m_Title.text = section.getTitle()
					holderwithButton.m_Text.text = section.getText()
					holderwithButton.m_Button.text = section.getTextButton()
					holderwithButton.setButtonLink(section.getLinkButton())
				}
				else -> {
					val holderwithoutButton = holder as MyViewHolderWithoutButton
					holderwithoutButton.m_Title.text = section.getTitle()
					holderwithoutButton.m_Text.text = section.getText()
				}
			}
		}
		
		override fun getItemCount(): Int {
			return m_SectionsList.size
		}
	}
\end{lstlisting}

\subsection {Video Screen}

For the Video Screen there are two layouts corresponding to portrait and landscape orientations of the screen.

For the portrait orientation:

\begin{lstlisting}
	<?xml version="1.0" encoding="utf-8"?>
	<androidx.appcompat.widget.LinearLayoutCompat
	xmlns:android="http://schemas.android.com/apk/res/android"
	android:orientation="vertical"
	android:layout_width="match_parent"
	android:layout_height="match_parent"
	android:background="@drawable/background">
	
	<VideoView
	android:id="@+id/video_view"
	android:layout_height="match_parent"
	android:layout_width="match_parent" />
	
	<androidx.recyclerview.widget.RecyclerView
	android:id="@+id/recyclerView"
	android:layout_width="match_parent"
	android:layout_height="match_parent" />
	
	</androidx.appcompat.widget.LinearLayoutCompat>
\end{lstlisting}

Here we have on top the video player and beneath it a RecyclerView that contains the buttons controlling which video is to be played.

For the landscape orientation:

\begin{lstlisting}
	<?xml version="1.0" encoding="utf-8"?>
	<RelativeLayout
	xmlns:android="http://schemas.android.com/apk/res/android"
	android:orientation="horizontal"
	android:layout_width="match_parent"
	android:layout_height="match_parent"
	android:background="@drawable/background">
	
	<androidx.recyclerview.widget.RecyclerView
	android:id="@+id/recyclerView"
	android:layout_width="200dp"
	android:layout_height="match_parent"
	android:layout_alignParentLeft="true"
	android:layout_alignParentTop="true" />
	<androidx.appcompat.widget.LinearLayoutCompat
	android:orientation="vertical"
	android:layout_width="match_parent"
	android:layout_height="match_parent"
	android:layout_gravity="center_vertical"
	android:layout_toRightOf="@+id/recyclerView"
	android:layout_alignParentRight="true">
	<VideoView
	android:id="@+id/video_view"
	android:layout_height="match_parent"
	android:layout_width="match_parent"
	android:layout_gravity="center_horizontal"/>
	</androidx.appcompat.widget.LinearLayoutCompat>
	
	</RelativeLayout>
\end{lstlisting}

Here we have a vertical RecyclerView on the left side and the video player on the right side of the screen.

The two Recycler View for the two screen orientations have the same ids. In code a single Recycler View object is created, but depending on orientation a different layout manager is used:

\begin{lstlisting}
	val recyclerView: RecyclerView = view.findViewById(R.id.recyclerView)
	var mLayoutManager = if (isHorizontal()) LinearLayoutManager(activity) else GridLayoutManager(activity,2)
	recyclerView.layoutManager = mLayoutManager
	recyclerView.itemAnimator = DefaultItemAnimator()
	recyclerView.adapter = m_VideosAdapter
\end{lstlisting}

The Recycler View is similar to the one in section \ref{info_screen} only it defines as layout for item a Button with the name of the video on it. Click on the button changes the video to be played, rewinds a video to its beginning or starts the video on YouTube.

Interesting are for this screen the different fragment life cycle methods implementations:

\begin{lstlisting}
	override fun onStart() {
		super.onStart()
		if (m_CurrentPositionInVideo != 0)
		m_VideoView!!.seekTo(m_CurrentPositionInVideo)
		
		m_VideoView!!.start()
	}
	
	override fun onResume() {
		super.onResume()
		if (!m_VideoView!!.isPlaying) {
			if (m_CurrentPositionInVideo != 0)
			m_VideoView!!.seekTo(m_CurrentPositionInVideo)
			
			m_VideoView!!.start()
		}
	}
	
	override fun onPause() {
		super.onPause()
		m_VideoView!!.pause()
		m_CurrentPositionInVideo = m_VideoView!!.currentPosition
		m_MovieList[m_CurrentVideo].setCurrentPosition(m_CurrentPositionInVideo)
		writeToVideoSettingsService()
	}
	
	override fun onStop() {
		m_VideoView!!.pause()
		super.onStop()
	}
\end{lstlisting}

In the onStop() implementation the video playback is stopped. In the onPause() implementation the current position in the video is saved. In the onResume() method the video is started where it was interrupted. 

\subsection{Preferences Screen}

There are two preferences screens inside the app one for the single player modus and another one for the multiplayer modus. 

The layout for vertical screen orientation for the single player modus is as follows:

\begin{lstlisting}
	<?xml version="1.0" encoding="utf-8"?>
	<layout xmlns:android="http://schemas.android.com/apk/res/android"
	xmlns:app="http://schemas.android.com/apk/res-auto">
		<data>
		<variable name="settingsData"
		type="com.planes.android.preferences.SinglePlayerSettingsViewModel"/>
		</data>
	
	<LinearLayout
		android:orientation="vertical"
		android:layout_width="match_parent"
		android:layout_height="match_parent"
		android:background="@drawable/background"
		android:id="@+id/options_layout">
		
		<LinearLayout
			android:orientation="vertical"
			android:layout_width="fill_parent"
			android:layout_height="wrap_content"
			android:background="?planesBackgroundEndColor"
			android:layout_margin="10dip">
			<TextView
				android:layout_width="wrap_content"
				android:layout_height="wrap_content"
				android:layout_margin="10dip"
				android:textSize="20sp"
				android:textStyle="bold"
				style="@style/CustomTextViewStyle"
				android:text="@string/game_difficulty_options"/>
			<LinearLayout
				android:orientation="horizontal"
				android:layout_width="fill_parent"
				android:layout_height="wrap_content">
				<TextView
					android:layout_width="wrap_content"
					android:layout_height="wrap_content"
					android:layout_margin="10dip"
					android:textSize="20sp"
					style="@style/CustomTextViewStyle"
					android:text="@string/computer_skill"/>
				<Spinner
					android:id="@+id/computer_skill_spinner"
					android:layout_width="match_parent"
					android:layout_height="wrap_content"
					android:layout_margin="10dip"
					android:minHeight="48dp"
					app:currentSkill="@={settingsData.m_ComputerSkill}"/>
			</LinearLayout>
			<LinearLayout
				android:orientation="horizontal"
				android:layout_width="fill_parent"
				android:layout_height="wrap_content">
				<TextView
					android:layout_width="wrap_content"
					android:layout_height="wrap_content"
					android:textSize="20sp"
					android:layout_margin="10dip"
					style="@style/CustomTextViewStyle"
					android:text="@string/show_plane_after_kill"/>
				<Spinner
					android:id="@+id/show_plane_after_kill"
					android:layout_width="match_parent"
					android:layout_height="wrap_content"
					android:layout_margin="10dip"
					android:minHeight="48dp"
					app:showPlaneAfterKill="@={settingsData.m_ShowPlaneAfterKill}"/>
			</LinearLayout>
			<TextView
				android:layout_width="wrap_content"
				android:layout_height="wrap_content"
				android:layout_margin="10dip"
				android:textSize="20sp"
				android:textStyle="bold"
				style="@style/CustomTextViewStyle"
				android:text="@string/multiplayer_options"/>
			<LinearLayout
				android:orientation="horizontal"
				android:layout_width="fill_parent"
				android:layout_height="wrap_content">
				<TextView
					android:layout_width="wrap_content"
					android:layout_height="wrap_content"
					android:layout_margin="10dip"
					android:textSize="20sp"
					style="@style/CustomTextViewStyle"
					android:text="@string/multiplayer_version"/>
				<Spinner
					android:id="@+id/multiplayer_spinner"
					android:layout_width="match_parent"
					android:layout_height="wrap_content"
					android:layout_margin="10dip"
					android:minHeight="48dp"
					app:multiplayerVersion="@={settingsData.m_MultiplayerVersion}"/>
			</LinearLayout>
			<Button
				android:id="@+id/options_savesettings"
				android:layout_width="wrap_content"
				android:layout_height="wrap_content"
				android:textSize="15sp"
				style="@style/ButtonColor"
				android:text="@string/savesettings"
				android:layout_gravity="end"/>
		</LinearLayout>
	</LinearLayout>
	</layout>
	
\end{lstlisting}

Here the three options for the game difficulty, whether to show the plane after being destroyed and whether to switch to multiplayer game or not are being input with Spinner views. The data are stored in a View Model with a so-called view model binding. This is configured at the beginning of the layout with the key words "variable name". The variable in this case is called settingsData of the type SinglePlayerSettingsViewModel. The fields that are being updated directly by the spinner through the view model binding are defined with the tags "app:currentSkill", "app:showPlaneAfterKill", "app:multiplayerVersion". 

The corresponding view model class looks as follows:

\begin{lstlisting} [caption = {Preferences View Model},label=pref_view_model1]
	class SinglePlayerSettingsViewModel(var computerSkill: Int, var showPlaneAfterKill: Boolean, var multiplayerVersion: Boolean) : ViewModel() {
		
		var m_ComputerSkill: Int = 0
		var m_ShowPlaneAfterKill: Boolean = false
		var m_MultiplayerVersion: Boolean = false
		
		init {
			m_ComputerSkill = computerSkill
			m_ShowPlaneAfterKill = showPlaneAfterKill
			m_MultiplayerVersion = multiplayerVersion
		}
	}
\end{lstlisting}

These preferences are persisted through a service called SinglePlayerPreferencesService. This service serves as interface to the shared preferences feature of Android. Persisting the view model occurs as follows:

\begin{lstlisting} [caption = {Persisting Preferences},label=pres_prefs1]
	override fun readPreferences() {
		val sp_gamedifficulty = m_Context.getSharedPreferences("gamedifficulty",
		Context.MODE_PRIVATE)
		computerSkill = sp_gamedifficulty.getInt("computerskill", 2)
		showPlaneAfterKill = sp_gamedifficulty.getBoolean("showkilledplane", false)
	}
	
	override fun writePreferences() {
		val sp_gamedifficulty = m_Context.getSharedPreferences("gamedifficulty",
		Context.MODE_PRIVATE).edit()
		sp_gamedifficulty.putInt("computerskill", computerSkill)
		sp_gamedifficulty.putBoolean("showkilledplane", showPlaneAfterKill)
		sp_gamedifficulty.apply()
	}
	
\end{lstlisting}

The service is created as a singleton and exist through the whole lifetime of the application.

\subsection{Game Screen}

The Game Fragment uses as layout a custom layout with custom views. The main concepts are explained in the following sections: \ref{custom_layouts} and \ref{custom_views}.

In the following I will describe how the GameBoard is created. This is also a custom layout with the following onLayout method:

\begin{lstlisting}
	
override fun onLayout(changed: Boolean, left: Int, top: Int, right: Int, bottom: Int) {
	val lp = layoutParams as PlanesVerticalLayoutParams
	m_GuessColor = lp.getGuessColor().defaultColor
	m_FirstPlaneColor = lp.getFirstPlaneColor().defaultColor
	m_SecondPlaneColor = lp.getSecondPlaneColor().defaultColor
	m_ThirdPlaneColor = lp.getThirdPlaneColor().defaultColor
	m_SelectedPlaneColor = lp.getSelectedPlaneColor().defaultColor
	m_CockpitColor = lp.getCockpitColor().defaultColor
	m_BoardColor = lp.getBoardColor().defaultColor
	m_PlaneOverlapColor = lp.getPlaneOverlapColor().defaultColor
	
	// These are the far left and right edges in which we are performing layout.
	val leftPos = paddingLeft
	val rightPos = right - left - paddingRight
	
	// These are the top and bottom edges in which we are performing layout.
	val topPos = paddingTop
	val bottomPos = bottom - top - paddingBottom
	val spacing = 0
	val newWidth = (min(bottomPos - topPos, rightPos - leftPos) - spacing) / (m_GRows + 2 * m_Padding)
	m_GridSquareSize = newWidth
	var verticalOffset = 0
	var horizontalOffset = 0
	if (bottomPos - topPos > rightPos - leftPos) {
		verticalOffset = (bottomPos - topPos - rightPos + leftPos) / 2
	} else {
		horizontalOffset = (rightPos - leftPos - bottomPos + topPos) / 2
	}
	val count = childCount
	for (i in 0 until count) {
		val child = getChildAt(i) as GridSquare
		child.width = newWidth
		// Log.d("Planes", "Set width " + i);
		val childLeft = leftPos + horizontalOffset + spacing / 2 + child.getColNo() * newWidth
		val childTop = topPos + verticalOffset + spacing / 2 + child.getRowNo() * newWidth
		val childRight = leftPos + horizontalOffset + spacing / 2 + child.getColNo() * newWidth + newWidth
		val childBottom = topPos + verticalOffset + spacing / 2 + child.getRowNo() * newWidth + newWidth
		child.layout(childLeft, childTop, childRight, childBottom)
	}
	updateBoards()
}	
	
\end{lstlisting}

In this function the cells of the board are being placed in the layout. In order to do that the offsets of their positions are first calculated as well as the size of the cells. Then the position of the single cell is calculated using the row and col coordinates stored in the cell themselves (of the GridSquare class).

The initialization of the cells of the board is being done in the init method of the class as follows:

\begin{lstlisting}
	private fun init(context: Context) {
		
		val gridSize = 1
		rowCount = m_GRows + 2 * m_Padding
		columnCount = m_GCols + 2 * m_Padding
		m_GridSquares = HashMap()
		for (i in 0 until m_GRows + 2 * m_Padding) {
			for (j in 0 until m_GCols + 2 * m_Padding) {
				val gs = GridSquare(context, gridSize)
				if (i < m_Padding || i >= m_GRows + m_Padding || j < m_Padding || j >= m_GCols + m_Padding) gs.setBackgroundColor(
				Color.YELLOW) else gs.setBackgroundColor(resources.getColor(
				R.color.aqua
				))
				gs.setGuessColor(m_GuessColor)
				gs.setGuess(-1)
				gs.setRowCount(m_GRows + 2 * m_Padding)
				gs.setColCount(m_GCols + 2 * m_Padding)
				gs.setRow(i)
				gs.setColumn(j)
				gs.setParent(this)
				val params = LayoutParams(spec(i, 1), spec(j, 1))
				addView(gs, params)
				val position = PositionBoardPane(i, j)
				m_GridSquares[position] = gs
			}
		}
	}
\end{lstlisting}

To display the information inside the cells according to the game model the function updateBoards() is used:

\begin{lstlisting}
	private fun updateBoards() {
		// draw the squares background
		for (i in 0 until m_GRows + 2 * m_Padding) {
			for (j in 0 until m_GCols + 2 * m_Padding) {
				val c = m_GridSquares[PositionBoardPane(i, j)]
				c!!.setGuess(-1)
				c.setBackgroundColor(computeSquareBackgroundColor(i, j))
				c.invalidate()
			}
		} // display background of square; double for loop
		
		val count = if (m_IsComputer) m_MultiplayerRound.getPlayerGuessesNo() else m_MultiplayerRound.getComputerGuessesNo()
		println("$count guesses")
		for (i in 0 until count) {
			var row: Int
			var col: Int
			var type: Int
			if (m_IsComputer) {
				row = m_MultiplayerRound.getPlayerGuessRow(i)
				col = m_MultiplayerRound.getPlayerGuessCol(i)
				type = m_MultiplayerRound.getPlayerGuessType(i)
			} else {
				row = m_MultiplayerRound.getComputerGuessRow(i)
				col = m_MultiplayerRound.getComputerGuessCol(i)
				type = m_MultiplayerRound.getComputerGuessType(i)
			}
			val c = m_GridSquares[PositionBoardPane(row + m_Padding, col + m_Padding)]
			// System.out.println("Guess type " + type);
			c!!.setGuess(type)
			c!!.setGuessColor(m_GuessColor)
			c.invalidate()
		}
	}
\end{lstlisting}

The control buttons of the game are also contained inside a custom layout - please see \ref{custom_layouts}. In the next version of the Android App these are not created in a custom layout anymore. Three versions of the controls are created with JetpackCompose for each of the different 3 screens of the game, this corresponds to a better app architecture. Only the game boards remain defined as custom layouts (TODO: add ref)

\subsection{Login Screen}

The Login screen is a simple screen with two fields: one for the username and one for the password, together with a submit button.

What is special to this screen is the fact by clicking on the Submit button a network call is made to the game server. For the network call we use the Retrofit library (see \ref{network_calls}). The asynchronous network calls are handled with the RxJava library (see \ref{rxjava}).

Once the login is performed the corresponding callback is called:

\begin{lstlisting}
	fun finalizeLoginSuccessful() {
		binding.creategame.isEnabled = true
		
		if (activity is MainActivity)
		(activity as MainActivity).setUsernameDrawerMenuMultiplayer()
		
		m_PlayersListService.startPolling()
		m_ReceiveChatMessagesService.startPolling()
		if (activity is MainActivity)
		(activity as MainActivity).startChatFragment()
		
	}
\end{lstlisting}

\subsection { Android Concepts }

\subsubsection { Activity }

Activity is a central class in an Android app. In an activity the appearance of the app is defined through an XML layout. Also the behaviour of the app as response to variouse events in the app life cycle are defined in the activity.

For example the layout of the Planes Android app is as follows:

\begin{lstlisting} [caption = {App Drawer Layout},label=drawer_layout]

<?xml version="1.0" encoding="utf-8"?>
	<androidx.drawerlayout.widget.DrawerLayout
	xmlns:android="http://schemas.android.com/apk/res/android"
	xmlns:app="http://schemas.android.com/apk/res-auto"
	android:id="@+id/drawer_layout"
	android:layout_width="match_parent"
	android:layout_height="match_parent"
	android:fitsSystemWindows="true">
		<RelativeLayout
		android:layout_width="match_parent"
		android:layout_height="match_parent">
			<androidx.appcompat.widget.LinearLayoutCompat
				android:id="@+id/coordinator_id"
				android:layout_width="match_parent"
				android:layout_height="match_parent"
				android:orientation="vertical"
				android:background="@drawable/background">
				<com.google.android.material.appbar.AppBarLayout
				android:layout_width="match_parent"
				android:layout_height="wrap_content"
				android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar">
				<androidx.appcompat.widget.Toolbar
				android:id="@+id/toolbar"
				android:layout_width="match_parent"
				android:layout_height="?attr/actionBarSize"
				app:theme="@style/MyToolbarTheme"
				app:layout_scrollFlags="enterAlways|scroll" />
				</com.google.android.material.appbar.AppBarLayout>
				<androidx.appcompat.widget.LinearLayoutCompat
				android:id="@+id/main_content"
				android:layout_width="match_parent"
				android:layout_height="match_parent"
				app:layout_behavior="@string/appbar_scrolling_view_behavior"/>
			</androidx.appcompat.widget.LinearLayoutCompat>
			<ProgressBar
			android:id="@+id/ProgressBarBottom"
			android:layout_width="350dp"
			android:layout_centerInParent="true"
			android:layout_height="350dp"
			android:foregroundTint="?planesProgressBarColor"
			android:progressTint="?planesProgressBarColor"
			android:indeterminateTint="?planesProgressBarColor"
			android:visibility="invisible" />
			<TextView
			android:id="@+id/LoaderLabelBottom"
			android:layout_width="wrap_content"
			android:layout_height="wrap_content"
			android:layout_margin="10dip"
			android:layout_alignParentBottom="true"
			android:textSize="20sp"
			android:textStyle="bold"
			style="@style/CustomTextViewStyle"
			android:text="@string/loader_text"
			android:visibility="invisible"/>
		</RelativeLayout>
	<com.google.android.material.navigation.NavigationView
	android:id="@+id/nav_view"
	android:layout_width="wrap_content"
	android:layout_height="wrap_content"
	android:layout_gravity="left"
	android:background="@drawable/background"
	app:menu="@menu/main_menu"
	app:theme="@style/NavigationDrawerStyle"
	app:headerLayout="@layout/nav_header"
	/>
	</androidx.drawerlayout.widget.DrawerLayout>
\end{lstlisting}
 
This xml defines the layout as a special type of layout: DrawerLayout. This includes the NavigationView which is the part of the layout which appears when clicking on the Hamburger button and allows the navigation to the different screens of the app. The content of the main activity screen is contained inside a RelativeLayout. In this layout are included a general use Progress Bar which is normally disabled but appears when different network calls are being made, the toolbar of the app and a placeholder for the different screens marked with the id main\_content.

\subsubsection { Activity Life Cycle }

\tikzstyle{startstop} = [rectangle, rounded corners, minimum width=3cm, 
minimum height=1cm, text centered, draw=black, fill=red!30]
\tikzstyle{process} = [rectangle, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=orange!30]
\tikzstyle{processb} = [rectangle, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=blue!30]
\tikzstyle{comment} = [rectangle, minimum width=3cm, minimum height=1cm, text centered,
text width=4cm, draw=white, fill=white]
\tikzstyle{arrow} = [thick,->,>=stealth]

\begin{figure}
	\caption{Activity Life Cycle diagram as it is presented on the Android developer pages}
	\label{fig:activity_life_cycle}
	\centering
		\begin{tikzpicture}[node distance=1.5cm]
			\node (start) [startstop] {Activity launched};
			\node (onCreate) [process, below of=start] {onCreate()};
			\node (onStart) [process, below of=onCreate] {onStart()};
			\node (onResume) [process, below of=onStart] {onResume()};
			\node (running) [startstop, below of=onResume] {Activity running};
			\node (commentOnPause) [comment, below of= running] {Another activity comes into the foreground};
			\node (onPause) [process, below of=commentOnPause] {onPause()};
			\node (commentOnStop) [comment, below of= onPause] {The activity is no longer visible};
			\node (onStop) [process, below of=commentOnStop] {onStop()};
			\node (commentOnDestroy) [comment, below of= onStop] {The activity is finishing or being destroyed by the system};
			\node (onDestroy) [process, below of=commentOnDestroy] {onDestroy()};
			\node (end) [startstop, below of=onDestroy] {Activitiy shut down};
			\node (onRestart) [process, right of=onStart, xshift=4cm] {onRestart()};
			\node (commentOnRestart) [comment, right of= onStop, xshift=4cm] {User navigates to the activity};
			\node (commentOnPauseRight) [comment, right of= onPause, xshift=2.5cm] {User returns to the activity};
			\node (commentOnPauseLeft) [comment, left of= onPause, xshift=-4cm] {Apps with higher priority need memory};
			\node (commentOnResumeLeft) [comment, left of= onResume, xshift=-4cm] {User navigates to the activity};
			\node (killed) [startstop, left of = running, xshift=-4cm] {App process killed};
			
			\draw [arrow] (start) -- (onCreate);
			\draw [arrow] (onCreate) -- (onStart);
			\draw [arrow] (onStart) -- (onResume);
			\draw [arrow] (onResume) -- (running);
			\draw [arrow] (running) -- (commentOnPause);
			\draw [arrow] (commentOnPause)  -- (onPause);
			\draw [arrow] (onPause) -- (commentOnStop);
			\draw [arrow] (commentOnStop) -- (onStop);
			\draw [arrow] (onStop) -- (commentOnDestroy);
			\draw [arrow] (commentOnDestroy) -- (onDestroy);
			\draw [arrow] (onDestroy) -- (end);
			\draw [arrow] (onRestart) -- (onStart);
			\draw [arrow] (onStop) -- (commentOnRestart);
			\draw [arrow] (commentOnRestart) -- (onRestart);
			\draw [arrow] (onPause) -- (commentOnPauseRight);
			\draw [arrow] (commentOnPauseRight) |- (onResume);
			\draw [arrow] (onPause) -> (commentOnPauseLeft);
			\draw [arrow] (onStop) -| (commentOnPauseLeft);
			\draw [arrow] (commentOnPauseLeft) -> (killed);
			\draw [arrow] (killed) -> (commentOnResumeLeft);
			\draw [arrow]  (commentOnResumeLeft) |- (onCreate);
			
		\end{tikzpicture}

\end{figure}

In figure \ref{fig:activity_life_cycle} one can see how various functions of the activity class are called depending in which state is the activity in following interaction with the user or with the Android operating system. The programmer has the possibilty to override these functions in order to customize the behaviour of the application.

In the following I will exemplify some of the methods as they are implemented in the Planes App. 

\begin{lstlisting} [caption = {onStop() life-cycle method},label=onStop_Android]
	override fun onStop() {
		m_SinglePlayerPreferencesService.writePreferences()
		m_MultiplayerPreferencesService.writePreferences()
		m_MainPreferencesService.writePreferences()
		m_VideoSettingsService.writePreferences()
		m_PlayersListService.stopPolling()
		m_ReceiveChatMessagesService.stopPolling()
		updateDatabaseFromNewMessagesFlags()
		super.onStop()
		Log.d("Planes", "onStop")
	}
\end{lstlisting}

In the onStop() method different screen configurations are saved in the so-called preferences of the app through calls of the method writePreferences(). The polling for the list of active players is stopped as well. The ROOM database is also updated with the information about the new messages.

\begin{lstlisting} [caption = {onResume() life-cycle method},label=onResume_Android]
	public override fun onResume() {
		super.onResume()
		if (m_MainPreferencesService.multiplayerVersion && m_MultiplayerRound.isUserLoggedIn()) {
			m_PlayersListService.startPolling()
			m_ReceiveChatMessagesService.startPolling()
			m_ReceiveChatMessagesService.setMainActivityUpdateFunction { updateNewMessagesFlags() }
		}
	}
\end{lstlisting}

In the onResume() method several configurations are made only for the the case when the user plays the multiplayer version and it is loogged in. These are:

\begin{itemize}
	\item Start polling for players' status
	\item Start polling for chat messages
	\item Configure the update of the main screen when receiving chat messages
	\item Update new messages flags on the top bar of the app
\end{itemize}


\subsubsection { Fragment }

Fragments represent a reusable portion of the UI. They are defined by their own layout files and have their own life cycle. They are hosted inside another fragment or an activity.

\subsubsection { Fragment Life Cycle }

\begin{figure}
	\caption{Fragment Life Cycle diagram as it is presented on the Android developer pages}
	\label{fig:fragment_life_cycle}
	\centering
	\begin{tikzpicture}[node distance=1.5cm]
		\node (onCreate) [processb] {onCreate()};
		\node (onCreateView) [processb, below of=onCreate] {onCreateView()};
		\node (onViewCreated) [processb, below of=onCreateView] {onViewCreated()};
		\node (onViewStateRestored) [processb, below of=onViewCreated] {onViewStateRestored()};
		\node (onStart) [processb, below of=onViewStateRestored] {onStart()};
		\node (onResume) [processb, below of= onStart] { onResume() };
		\node (onPause) [process, below of=onResume] {onResume()};
		\node (onStop) [process, below of= onPause] {onStop()};
		\node (onSaveInstanceState) [process, below of=onStop] {onSaveInstanceState()};
		\node (onDestroyView) [process, below of= onSaveInstanceState] {onDestroyView()};
		\node (onDestroy) [process, below of=onDestroyView] {onDestroy()};
		
		\node (ccreated) [comment, left of = onCreateView, xshift = -4cm] {CREATED};
		\node (cstarted) [comment, left of = onStart, xshift = -4cm] {STARTED};
		\node (cresumed) [comment, left of = onResume, xshift = -4cm] {RESUMED};
		\node (cstarted1) [comment, left of = onPause, xshift = -4cm] {STARTED};
		\node (ccreated1) [comment, left of = onSaveInstanceState, xshift = -4cm] {CREATED};
		\node (cdestroyed) [comment, left of = onDestroy, xshift = -4cm] {DESTROYED};
		
		\draw [arrow] (onCreate) -- (onCreateView);
		\draw [arrow] (onCreateView) -- (onViewCreated);
		\draw [arrow] (onViewCreated) -- (onViewStateRestored);
		\draw [arrow] (onViewStateRestored) -- (onStart);
		\draw [arrow] (onStart) -- (onResume);
		\draw [arrow] (onResume) -- (onPause);
		\draw [arrow] (onPause) -- (onStop);
		\draw [arrow] (onStop) -- (onSaveInstanceState);
		\draw [arrow] (onSaveInstanceState) -- (onDestroyView);
		\draw [arrow] (onDestroyView) -- (onDestroy);
	
	\end{tikzpicture}
	
\end{figure}

I am listing below a few life cycle methods from the CreateGameFragment which corresponds to the screen where the user connects to the game.

\begin{lstlisting}
	override fun onDetach () {
		super.onDetach()
		hideLoading()
		if (this::m_RefreshGameStatusSubscription.isInitialized)
		m_RefreshGameStatusSubscription.dispose()
		if (this::m_CreateGameSubscription.isInitialized)
		m_CreateGameSubscription.dispose()
		if (this::m_ConnectToGameSubscription.isInitialized)
		m_ConnectToGameSubscription.dispose()
		if (this::m_PollForOpponentSubscription.isInitialized)
		m_PollForOpponentSubscription.dispose()
	}
\end{lstlisting}

In the method onDetach() corresponding to the fragment being removed from the containing fragment or activity I am disposing network call objects. I am also hiding the loader animation corresponding to the user waiting for the opponent to connect to the game. 

\begin{lstlisting}
	 override fun onResume() {
		super.onResume()
		reinitializeFromState()
	}
\end{lstlisting}

\begin{lstlisting}
	private fun reinitializeFromState() {
		when(m_CreateGameSettingsService.createGameState) {
			CreateGameStates.NotSubmitted -> {
				binding.ProgressBarCreateGame.isVisible = false
				binding.startPlaying.isEnabled = false
			}
			CreateGameStates.Submitted -> {
				binding.ProgressBarCreateGame.isVisible = false
				binding.startPlaying.isEnabled = false
				checkGameStatus()
			}
			CreateGameStates.GameCreated -> { pollForGameConnection() }
			CreateGameStates.ConnectedToGame -> { connectedToGame() }
		}
	}
\end{lstlisting}

In the onResume() method the method reinitializeFromState() is called. This resets the screen to the state it had before being destroyed.

\subsubsection{Custom Views} \label{custom_views}

Most of the elements that appear in the XML Layout are derived from the class View, the basis of the hierarchy of displayable elements. In some cases it is required to create custom views. As an example I will sketch the implementation of the view ColouredSurfaceWithText which is one of the game control buttons.

Essential to creating a custom view is to override the methods onDraw() and onMeasure() of the View.

\begin{lstlisting}
	public override fun onDraw(canvas: Canvas) {
		m_Paint.color = m_BackgroundColor
		canvas.drawRect(0f, 0f, width.toFloat(), height.toFloat(), m_Paint)
		m_Paint.color = m_ForegroundColor
		drawTextFitToSizeOneLine(m_Text, m_TextSize, canvas, m_Paint, width, height)
	}
\end{lstlisting}

The onDraw() method has a Canvas parameter which allows drawing onto. In this case a Rect is drawn with the specified background color along with a text with the specified foreground color. 

\begin{lstlisting}
	 override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
		val lp = layoutParams as PlanesVerticalLayoutParams
		if (!this::m_Text.isInitialized) m_Text = lp.getText()
		m_BackgroundColor = lp.getBackgroundColor().defaultColor
		m_ForegroundColor = lp.getForegroundColor().defaultColor
		val measuredHeight = measureHeightOneLineText(heightMeasureSpec, m_Paint, m_Text)
		val measuredWidth = measureWidthOneLineText(widthMeasureSpec, m_Paint, m_Text)
		setMeasuredDimension(measuredWidth, measuredHeight)
	}
\end{lstlisting}

In the onMeasure() method the layout parameters of the view are being read: the background color, the foreground color and the text to be displayed and based on that the size of the view is being calculated.

\begin{lstlisting}
	fun measureHeightOneLineText(measureSpec: Int, paint: Paint, text: String): Int {
		View.MeasureSpec.getMode(measureSpec)
		val specSize = View.MeasureSpec.getSize(measureSpec)
		var resultHeight = 10
		paint.textSize = 20f
		val bounds = Rect()
		paint.getTextBounds(text, 0, text.length, bounds)
		if (bounds.height() > resultHeight) resultHeight = bounds.height()
		if (specSize > resultHeight) resultHeight = specSize
		return resultHeight
	}
\end{lstlisting}

The height of the View is being calculated in the function measureHeightOneLineText() as follows: first the size of the text is being determined from the paint object, if it is bigger than the minimum dimension of 10 than this is considered as the intermediary height of the View, further more if the specified height is still bigger than this intermediary value, the specified height is taken as the View's height.

A similar reasoning is used for determining the View's width. Finally with the help of the function setMeasuredDimension() the calculated dimensions of the View are set.

\subsubsection {Custom Layouts} \label{custom_layouts}

When creating a custom layout one derives from ViewGroup, which is the basis class for layouts in AndroidXML.

One needs to override the method onLayout which receives as parameters the position (left, right, bottom, top). The method is triggered after the ViewGroup was placed inside the parent ViewGroup and is responsible for laying out its children.

In PlanesAndroid I use a custom layout for the game board(s) along with the control buttons for the game (which are different at different game stages). This layout is different depending on the game stage. There are three game stages: board editing, game, game not started.

This is a longer function so I will present it in two parts. In the first part a preprocessing is performed:

\begin{lstlisting}
	for (i in 0 until count) {
		val child = getChildAt(i)
		if (child is GameBoardSinglePlayer) {
			m_GameBoards.add(child)
		} else {
			val lp = child.layoutParams as PlanesVerticalLayoutParams
			if (!(lp.m_Row == 0 || lp.m_Col == 0 || lp.m_GameStage == -1)) {
				if (!m_GameControls.containsKey(lp.m_GameStage)) {
					m_GameControls[lp.m_GameStage] = ArrayList()
					m_GameControlsMaxRow[lp.m_GameStage] = 0
					m_GameControlsMaxCol[lp.m_GameStage] = 0
				}
				val viewsForGameStage = m_GameControls[lp.m_GameStage]!!
				if (lp.m_GameStage != m_GameStage.value) {
					child.visibility = GONE
				} else {
					child.visibility = VISIBLE
				}
				viewsForGameStage.add(child)
				val maxRow = m_GameControlsMaxRow[lp.m_GameStage]!!
				val rowspan = if (lp.m_RowSpan != 0) lp.m_RowSpan - 1 else 0
				val colspan = if (lp.m_ColSpan != 0) lp.m_ColSpan - 1 else 0
				if (lp.m_Row + rowspan > maxRow)
				m_GameControlsMaxRow[lp.m_GameStage] = lp.m_Row + rowspan
				val maxCol = m_GameControlsMaxCol[lp.m_GameStage]!!
				if (lp.m_Col + colspan > maxCol)
				m_GameControlsMaxCol[lp.m_GameStage] = lp.m_Col + colspan
			}
		}
	}
\end{lstlisting}

The children of the layout are being read. If the child is a game board then it is added to the list of GameBoards. If the child is not a game board then it is a button/ control surface of the game controls. The game controls are added to an array list corresponding to the game stage. One also saves in a hash map the maximum row positions and maximum col positions for each game stage.

In the second part of the function the positioning of the layout children is being performed. I am only going to show the positioning for the board editing stage of the game.

\begin{lstlisting}
	if (m_Tablet) {
		if (m_Vertical) {
			setPlayerBoardPosition(0, 0, layoutWidth, layoutHeight / 2, true)
			setGameControlsPositions(0, layoutHeight / 2, layoutWidth, layoutHeight)
		} else {
			setPlayerBoardPosition(0, 0, layoutWidth / 2, layoutHeight, true)
			setGameControlsPositions(layoutWidth / 2, 0, layoutWidth, layoutHeight)
		}
	} else {
		if (m_Vertical) {
			setFirstBoardPosition(0, 0, layoutWidth, layoutWidth)
			setGameControlsPositions(0, layoutWidth, layoutWidth, layoutHeight)
		} else {
			setFirstBoardPosition(0, 0, layoutHeight, layoutHeight)
			setGameControlsPositions(layoutHeight, 0, layoutWidth, layoutHeight)
		}
	}
\end{lstlisting}

The functions for laying out the boards look like this:

\begin{lstlisting}
	private fun setPlayerBoardPosition(left: Int, top: Int, right: Int, bottom: Int, hideOthers: Boolean) {
		for (board in m_GameBoards) {
			if (board.isPlayer()) {
				board.layout(left, top, right, bottom)
				board.visibility = VISIBLE
			} else {
				if (hideOthers) board.visibility = GONE else board.visibility = VISIBLE
			}
		}
	}
\end{lstlisting}

The boards are again custom layouts which only make the placement and display of the planes and guesses in a grid format in the given coordinates.

The function for laying out the game controls looks like:

\begin{lstlisting}

	private fun setGameControlsPositions(left: Int, top: Int, right: Int, bottom: Int) {
		if (!m_GameControlsMaxRow.containsKey(m_GameStage.value))
		return
		
		val maxRow = m_GameControlsMaxRow[m_GameStage.value]!!
		val maxCol = m_GameControlsMaxCol[m_GameStage.value]!!
		val stepX = (right - left) / (maxCol + 2)
		val stepY = (bottom - top) / (maxRow + 2)
		var currentOptimalTextSize = 100
		
		//compute text size
		for (view in m_GameControls[m_GameStage.value]!!) {
			if (view !is ViewWithText) continue
			val lp = view.layoutParams as PlanesVerticalLayoutParams
			val rowspan = if (lp.m_RowSpan != 0) lp.m_RowSpan else 1
			val colspan = if (lp.m_ColSpan != 0) lp.m_ColSpan else 1
			val heightMeasureSpec = MeasureSpec.makeMeasureSpec(rowspan * stepY, MeasureSpec.UNSPECIFIED)
			val widthMeasureSpec = MeasureSpec.makeMeasureSpec(colspan * stepX, MeasureSpec.UNSPECIFIED)
			view.measure(widthMeasureSpec, heightMeasureSpec)
			val actualWidth = view.measuredWidth
			val actualHeight = view.measuredHeight
			currentOptimalTextSize = (view as ViewWithText).getOptimalTextSize(currentOptimalTextSize, actualWidth - m_GridSpacing, actualHeight - m_GridSpacing)
		}
		
		//layout
		for (view in m_GameControls[m_GameStage.value]!!) {
			val lp = view.layoutParams as PlanesVerticalLayoutParams
			val rowspan = if (lp.m_RowSpan != 0) lp.m_RowSpan else 1
			val colspan = if (lp.m_ColSpan != 0) lp.m_ColSpan else 1
			val heightMeasureSpec = MeasureSpec.makeMeasureSpec(rowspan * stepY, MeasureSpec.UNSPECIFIED)
			val widthMeasureSpec = MeasureSpec.makeMeasureSpec(colspan * stepX, MeasureSpec.UNSPECIFIED)
			view.measure(widthMeasureSpec, heightMeasureSpec)
			val actualWidth = view.measuredWidth - m_GridSpacing
			val actualHeight = view.measuredHeight - m_GridSpacing
			val viewCenterX = left + lp.m_Col * stepX + colspan * stepX / 2
			val viewCenterY = top + lp.m_Row * stepY + rowspan * stepY / 2
			if (view is ViewWithText) (view as ViewWithText).setTextSize(currentOptimalTextSize)
			view.layout(viewCenterX - actualWidth / 2, viewCenterY - actualHeight / 2, viewCenterX + actualWidth / 2, viewCenterY + actualHeight / 2)
			
		}
	}

\end{lstlisting}

The game controls views were already saved in the hash map m\_GameControls. They are positioned in a grid like fashion where the row, col, rowspan, colspan are given in the xml layout. To compute the discrete steps in x and y direction the maxrows and maxcols for the given game stage are used (They were computed in the preprocessing step). The view.measure() function is called to get the actual width and height of the view. The view center position is computed from the discrete steps in the x and y directions. Based on these information the view is being layed out with the help of the function view.layout().

\subsection { Other Concepts }

\subsubsection { Network calls with Retrofit } \label{network_calls}

Retrofit is a very popular library for network calls. In order to use it one needs to define an API corresponding to the api offered by the network service and to create an object which will be used to perform the network calls.

The API for the Planes API is as follows:

\begin{lstlisting} 
	interface MultiplayerCommApi {
		@POST("status/getversion")
		@Headers("Content-Type: application/json")
		fun getVersion(): Observable<retrofit2.Response<VersionResponse>>
		
		@POST("login/")
		@Headers("Content-Type: application/json")
		fun login(@Body user: LoginRequest): Observable<retrofit2.Response<LoginResponse>>
		
		@POST("operations/logout")
		@Headers("Content-Type: application/json")
		fun logout(@Header("Authorization") authorization: String, @Body user: LogoutRequest): Observable<retrofit2.Response<LogoutResponse>>
		
		@POST("users/deactivate_user")
		@Headers("Content-Type: application/json")
		fun deactivateUser(@Header("Authorization") authorization: String, @Body user: DeleteUserRequest): Observable<retrofit2.Response<DeleteUserResponse>>
		
		@POST("users/registration_request")
		@Headers("Content-Type: application/json")
		fun register(@Body user: RegistrationRequest): Observable<retrofit2.Response<RegistrationResponse>>
		
		@POST("users/registration_confirm")
		@Headers("Content-Type: application/json")
		fun norobot(@Body user: NoRobotRequest): Observable<retrofit2.Response<NoRobotResponse>>
		
		@POST("game/status")
		@Headers("Content-Type: application/json")
		fun refreshGameStatus(@Header("Authorization") authorization: String, @Body game: GameStatusRequest): Observable<retrofit2.Response<GameStatusResponse>>
		
		@POST("game/create")
		@Headers("Content-Type: application/json")
		fun createGame(@Header("Authorization") authorization: String, @Body game: CreateGameRequest): Observable<retrofit2.Response<CreateGameResponse>>
		
		@POST("game/connect")
		@Headers("Content-Type: application/json")
		fun connectToGame(@Header("Authorization") authorization: String, @Body game: ConnectToGameRequest): Observable<retrofit2.Response<ConnectToGameResponse>>
		
		
		@POST("round/myplanespositions")
		@Headers("Content-Type: application/json")
		fun sendPlanePositions(@Header("Authorization") authorization: String, @Body positions: SendPlanePositionsRequest): Observable<retrofit2.Response<SendPlanePositionsResponse>>
		
		@POST("round/otherplanespositions")
		@Headers("Content-Type: application/json")
		fun acquireOpponentPlanePositions(@Header("Authorization") authorization: String, @Body request: AcquireOpponentPositionsRequest): Observable<retrofit2.Response<AcquireOpponentPositionsResponse>>
		
		@POST("round/end")
		@Headers("Content-Type: application/json")
		fun sendWinner(@Header("Authorization") authorization: String, @Body request: SendWinnerRequest): Observable<retrofit2.Response<SendWinnerResponse>>
		
		@POST("round/mymove")
		@Headers("Content-Type: application/json")
		fun sendOwnMove(@Header("Authorization") authorization: String, @Body request: SendNotSentMovesRequest): Observable<retrofit2.Response<SendNotSentMovesResponse>>
		
		@POST("round/cancel")
		@Headers("Content-Type: application/json")
		fun cancelRound(@Header("Authorization") authorization: String, @Body request: CancelRoundRequest): Observable<retrofit2.Response<CancelRoundResponse>>
		
		@POST("round/start")
		@Headers("Content-Type: application/json")
		fun startRound(@Header("Authorization") authorization: String, @Body request: StartNewRoundRequest): Observable<retrofit2.Response<StartNewRoundResponse>>
		
		@POST("users/available_users")
		@Headers("Content-Type: application/json")
		fun getPlayersList(@Header("Authorization") authorization: String, @Body request: PlayersListRequest): Observable<retrofit2.Response<PlayersListResponse>>
		
		@POST("chat/get_messages")
		@Headers("Content-Type: application/json")
		fun getChatMessages(@Header("Authorization") authorization: String, @Body request: ReceiveChatMessagesRequest): Observable<retrofit2.Response<ReceiveChatMessagesResponse>>
		
		@POST("chat/send_message")
		@Headers("Content-Type: application/json")
		fun sendChatMessage(@Header("Authorization") authorization: String, @Body request: SendChatMessageRequest): Observable<retrofit2.Response<SendChatMessageResponse>>
	}
\end{lstlisting}

To build the object used to perform the network calls one does as follows:

\begin{lstlisting}
	val spec = ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
	.tlsVersions(TlsVersion.TLS_1_2)
	.cipherSuites(
	CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
	CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
	CipherSuite.TLS_DHE_RSA_WITH_AES_128_GCM_SHA256
	)
	.build()
	val okHttpClient = OkHttpClient.Builder()
	.connectTimeout(OK_HTTP_CLIENT_TIMEOUT, TimeUnit.SECONDS)
	.readTimeout(OK_HTTP_CLIENT_TIMEOUT, TimeUnit.SECONDS)
	.writeTimeout(OK_HTTP_CLIENT_TIMEOUT, TimeUnit.SECONDS)
	.callTimeout(OK_HTTP_CLIENT_TIMEOUT, TimeUnit.SECONDS)
	.followSslRedirects(true)
	.retryOnConnectionFailure(true)
	.followRedirects(true)
	.connectionSpecs(Collections.singletonList(spec))
	.build()
	
	val retrofit = Retrofit.Builder()
	.addCallAdapterFactory(RxJava2CallAdapterFactory.create())
	.addConverterFactory(GsonConverterFactory.create())
	.client(okHttpClient)
	.baseUrl("https://planes.planes-android.com:8443/planesserver/")
	.build()
	m_Service = retrofit.create((MultiplayerCommApi::class.java))
\end{lstlisting}
	
	This specifies a configuration for building the network call object:

\begin{itemize}
	\item which TLS version is to be used : in this case 1.2
	\item which type of client to use: in this case okhttp, another library for network calls
	\item which are the timeouts for read, write and call
	\item which library to use for handling the asynchronous calls: RxJava
	\item which library to use for delivering the results: Gson
	\item which API is to be used for the calls: MultiplayeCommApi
\end{itemize}	

After these were defined performing a network call to the network server can be as easy as:

\begin{lstlisting}
	fun login(username: String, password: String): Observable<Response<LoginResponse>> {
		return m_Service.login(LoginRequest(username, password))
	}
\end{lstlisting}

\subsubsection { Asynchronous calls with RxJava } \label{rxjava}

As seen in the last listing of the previous section the return value of a network call for Planes Android is an object of the generic class Observable. This is a RxJava class that allows the program to react asynchronously to the network request.

To make the network call using the observable object I use the following construct:

\begin{lstlisting}
	m_RetrofitSubscription = m_Observable
	.delay (1500, TimeUnit.MILLISECONDS ) //TODO: to remove this
	.subscribeOn(Schedulers.io())
	.observeOn(AndroidSchedulers.mainThread())
	.doOnSubscribe { doOnSubscribe() }
	.doOnTerminate { doOnTerminate() }
	.doOnComplete { doOnTerminate() }
	.subscribe({data -> finishedRequest(data.code(), data.errorBody()?.string(), data.headers(), data.body())}
	, {error -> error.localizedMessage?.let { setRequestError(it) } })
\end{lstlisting}

Using this type of call one can specify the callback methods that are called when various events related to the call occur.

\section{PlanesCompose}

Following new developments of Android development libraries I am porting the project to a new technology: JetPack Compose. 

\subsection{Navigation}

The basis of the application is the navigation. Here I wish to keep the drawer navigation. 
The navigation drawer and main screen content are defined as follows (\ref{drawer_compose})

\begin{lstlisting}  [caption = {Drawer Navigation in Jetpack Compose},label=drawer_compose]
	ModalNavigationDrawer(
	drawerState = drawerState,
	drawerContent = {
		ModalDrawerSheet {
			DrawerContent(navController = navController,
			drawerScope = scope,
			drawerState = drawerState)
		}
	},
	gesturesEnabled = true
	) {
		Scaffold(
		topBar = {
			TopBar(
			modifier = Modifier.padding(30.dp)
			.height(100.dp).fillMaxWidth(),
			onOpenDrawer = {
				scope.launch {
					drawerState.apply {
						if (isClosed)
						open()
						else
						close()
					}
				}
			},
			currentScreenName = currentScreenState.value
			)
		}
		) { padding ->
			ScreenContent(modifier = Modifier.padding(padding),
			currentScreenState = currentScreenState,
			navController = navController)
		}
	}
\end{lstlisting}

The design of the drawer is defined under the drawer\_content variable. The layout of the application screen is defined under the ending lambda of the ModalNavigationDrawer composable . 

In listing \ref{drawer_layout__compose} the structure of the drawer is shown. Probably this is not the final code for the drawer but the principle will stay the same. So the drawer is a Column layout in which screen names are stacked one under another. The screen names are grouped in sections and a HorizontalDivider is shown between sections .

\begin{lstlisting} [caption = {Drawer View},label=drawer_layout__compose]
	@Composable
	fun DrawerContent(modifier: Modifier = Modifier,
	navController: NavController,
	drawerScope: CoroutineScope,
	drawerState: DrawerState,
	) {
		
		Column(
		modifier = Modifier.padding(horizontal = 16.dp)
		.verticalScroll(rememberScrollState())
		) {
			Text(
			text = "Planes",
			modifier = Modifier.padding(16.dp),
			style = MaterialTheme.typography.titleLarge
			)
			
			HorizontalDivider()
			
			DrawerMenuItemGeneric("Login", {
				drawerScope.launch {
					drawerState.close()
				}
				navController.navigate(route = PlanesScreens.Login.name)
			})
			
			DrawerMenuItemGeneric("Logout", {
				drawerScope.launch {
					drawerState.close()
				}
				navController.navigate(route = PlanesScreens.Logout.name)
			})
			
			DrawerMenuItemGeneric("Register", {
				drawerScope.launch {
					drawerState.close()
				}
				navController.navigate(route = PlanesScreens.Register.name)
			})
			
			DrawerMenuItemGeneric("Chat", {
				drawerScope.launch {
					drawerState.close()
				}
				navController.navigate(route = PlanesScreens.Chat.name)
			})
			
			Text(
			text = "Single Player Game",
			modifier = Modifier.padding(16.dp),
			style = MaterialTheme.typography.titleMedium
			)
			DrawerMenuItemGeneric("Game", {
				drawerScope.launch {
					drawerState.close()
				}
				navController.navigate(route = PlanesScreens.SinglePlayerGame.name)
			})
			
			DrawerMenuItemGeneric("Preferences", {
				drawerScope.launch {
					drawerState.close()
				}
				navController.navigate(route = PlanesScreens.SinglePlayerPreferences.name)
			})
			
			DrawerMenuItemGeneric("Game Statistics", {
				drawerScope.launch {
					drawerState.close()
				}
				navController.navigate(route = PlanesScreens.SinglePlayerGameStatistics.name)
			})
			
			
			Text(
			text = "Multiplayer Game",
			modifier = Modifier.padding(16.dp),
			style = MaterialTheme.typography.titleMedium
			)
			DrawerMenuItemGeneric("Game", {
				drawerScope.launch {
					drawerState.close()
				}
				navController.navigate(route = PlanesScreens.MultiplayerGame.name)
			})
			
			DrawerMenuItemGeneric("Preferences", {
				drawerScope.launch {
					drawerState.close()
				}
				navController.navigate(route = PlanesScreens.MultiplayerPreferences.name)
			})
			
			DrawerMenuItemGeneric("Game Statistics", {
				drawerScope.launch {
					drawerState.close()
				}
				navController.navigate(route = PlanesScreens.MultiplayerGameStatistics.name)
			})
			
			Text(
			text = "Info",
			modifier = Modifier.padding(16.dp),
			style = MaterialTheme.typography.titleMedium
			)
			
			DrawerMenuItemGeneric("About", {
				drawerScope.launch {
					drawerState.close()
				}
				navController.navigate(route = PlanesScreens.Info.name)
			})
			
			DrawerMenuItemGeneric("Tutorials", {
				drawerScope.launch {
					drawerState.close()
				}
				navController.navigate(route = PlanesScreens.Tutorials.name)
			})
			
			DrawerMenuItemGeneric("Delete User", {
				drawerScope.launch {
					drawerState.close()
				}
				navController.navigate(route = PlanesScreens.DeleteUser.name)
			})
		}
	}
\end{lstlisting}

Each screen name is represented by an element of the composable DrawerMenuItemGeneric which receive parameters the screen name and a lambda function that it is to be called when the screen name is clicked. The call navController.navigate() makes the screen transition. It corresponds to the supportFragmentManager.beginTransaction() from \ref{start_norobot_fragment}.

\subsection{Main Screen}

The structure of the application screen is also defined in listing \ref{drawer_compose} which is the definition of the drawer navigation. This is defined with a Scaffold composable composed of a top bar together with the content of the screen.

\begin{lstlisting} [caption = {Main Screen Layout},label=main_screen]
	Scaffold(
	topBar = {
		TopBar(
		modifier = Modifier.padding(30.dp)
		.height(100.dp).fillMaxWidth(),
		onOpenDrawer = {
			scope.launch {
				drawerState.apply {
					if (isClosed)
					open()
					else
					close()
				}
			}
		},
		currentScreenName = currentScreenState.value
		)
	}
	) { padding ->
		ScreenContent(modifier = Modifier.padding(padding),
		currentScreenState = currentScreenState,
		navController = navController)
	}
\end{lstlisting} 

TopBar is defined as follows:

\begin{lstlisting}  [caption = {Top Bar},label=top_bar]
	TopBar(modifier: Modifier = Modifier,
	onOpenDrawer: () -> Unit = {},
	currentScreenName: String
	) {
		TopAppBar(
		colors = TopAppBarDefaults.topAppBarColors(
		containerColor = MaterialTheme.colorScheme.surfaceVariant
		),
		navigationIcon = {
			Icon(
			imageVector = Icons.Default.Menu,
			contentDescription = "Navigation Icon",
			modifier = Modifier.clickable {
				onOpenDrawer()
			}. padding(start = 16.dp, end = 8.dp)
			.size(28.dp))
		},
		title = {
			Text(text = currentScreenName)
		},
		actions = {
			Icon(
			imageVector = Icons.Default.AccountBox,
			contentDescription = "Navigation Icon",
			modifier = Modifier.padding(start = 16.dp, end = 8.dp).size(28.dp)
			)
			Icon(
			imageVector = Icons.Default.Notifications,
			contentDescription = "Navigation Icon",
			modifier = Modifier.padding(start = 16.dp, end = 8.dp)
			.size(28.dp))
		}
		)
	}
	
\end{lstlisting}

This uses the predefined composable TopAppBar which receives as parameters a navigation icon (the Hamburger button), the title displayed as well as actions which can be added to this bar to be called from everywhere in the app. The variable currentScreenName is defined such that when a new screen is shown the title of the screen is displayed in the top bar.

The ScreenContent composable defines the changing content of the main screen as follows:

\begin{lstlisting}
	@Composable
	fun ScreenContent(modifier: Modifier, currentScreenState: MutableState<String>,
	navController: NavHostController
	) {
		PlanesNavigation(modifier = modifier,
		currentScreenState, navController,
		context = LocalContext.current)
	}
\end{lstlisting}

PlanesNavigation is a composable that associates to the application screen names composable functions representing the respective screens.

\begin{lstlisting}
	@Composable
	fun PlanesNavigation(modifier: Modifier, currentScreenState: MutableState<String>,
	navController: NavHostController, context: Context) {
		
		NavHost(
		navController = navController,
		startDestination = PlanesScreens.Info.name) {
			composable(PlanesScreens.SinglePlayerGame.name) {
				SinglePlayerGameScreen(modifier = modifier, currentScreenState, navController = navController)
			}
			composable(PlanesScreens.SinglePlayerGameStatistics.name) {
				SinglePlayerGameStatisticsScreen(modifier = modifier, currentScreenState, navController = navController)
			}
			composable(PlanesScreens.SinglePlayerPreferences.name) {
				SinglePlayerPreferencesScreen(modifier = modifier, currentScreenState, navController = navController)
			}
			composable(PlanesScreens.MultiplayerGame.name) {
				MultiplayerGameScreen(modifier = modifier, currentScreenState, navController = navController)
			}
			composable(PlanesScreens.MultiplayerGameStatistics.name) {
				MultiplayerGameStatisticsScreen(modifier = modifier, currentScreenState, navController = navController)
			}
			composable(PlanesScreens.MultiplayerPreferences.name) {
				MultiplayerPreferencesScreen(modifier = modifier, currentScreenState, navController = navController)
			}
			composable(PlanesScreens.Info.name) {
				AboutScreen(modifier = modifier, currentScreenState, navController = navController,
				aboutEntryList = AboutEntryRepository.create("0.1", context = context))
			}
			composable(PlanesScreens.Tutorials.name) {
				VideoScreen(modifier = modifier, currentScreenState, navController = navController)
			}
			composable(PlanesScreens.Login.name) {
				LoginScreen(modifier = modifier, currentScreenState, navController = navController)
			}
			composable(PlanesScreens.Logout.name) {
				LogoutScreen(modifier = modifier, currentScreenState, navController = navController)
			}
			composable(PlanesScreens.Register.name) {
				RegisterScreen(modifier = modifier, currentScreenState, navController = navController)
			}
			composable(PlanesScreens.DeleteUser.name) {
				DeleteUserScreen(modifier = modifier, currentScreenState, navController = navController)
			}
			composable(PlanesScreens.Chat.name) {
				ChatScreen(modifier = modifier, currentScreenState, navController = navController)
			}
		}
\end{lstlisting}

\subsection{Info Screen}

In this version of the Planes App the contents of the info screen is the same as in the PlanesAndroid app. But the JetPackCompose framework does not offer a Recycler View anymore. Let's see how the functionality is replicated in this case.

A data model class is used which is identical to the one used for the Recycler View. I only gave it a different name: AboutEntryModel. The method for creating the data repository is the same, it is only integrated in the companion object of a class called AboutEntryRepository. 

The layout for one entry in the About Screen is now created with a composable function.

\begin{lstlisting}
	fun AboutEntryRow(entry: AboutEntryModel, context: Context) {
		
		val uriHandler = LocalUriHandler.current
		
		Column(modifier = Modifier.padding(4.dp).
		fillMaxWidth())
		{
			Text(text = entry.getTitle(),
			style = MaterialTheme.typography.titleMedium)
			Text(text = entry.getText(),
			style = MaterialTheme.typography.bodyMedium)
			if (entry.hasButton()) {
				Button(modifier = Modifier.align(Alignment.End),
				onClick = {
					uriHandler.openUri(entry.getLinkButton())
				}) {
					Text(text = entry.getTextButton())
				}
			}
		}
	}
\end{lstlisting}

The difference from \ref{layout_button_info_screen} and \ref{layout_with_button_info_screen} is that a single construct is needed to create the layout. This is possible through the if command in the AboutEntryRow composable.

Finally to glue everything together a LazyColumn composable is used as follows:

\begin{lstlisting}
	fun AboutScreen(modifier: Modifier, currentScreenState: MutableState<String>,
	context: Context, navController: NavController,
	aboutEntryList: List<AboutEntryModel>) {
		
		currentScreenState.value = PlanesScreens.Info.name
		
		Surface(modifier = modifier,
		color = MaterialTheme.colorScheme.background) {
			Column(modifier = Modifier.fillMaxWidth(),
			horizontalAlignment = Alignment.CenterHorizontally,
			verticalArrangement = Arrangement.Center) {
				LazyColumn {
					items(items = aboutEntryList) {
						AboutEntryRow(entry = it, context)
					}
				}
			}
		}
	}
\end{lstlisting}

I personally prefer the implementation in JetPackCompose as it is simpler and eleganter.

\subsection {Video Screen}

For the video screen I am using the Exoplayer library. The definition of the player is as follows:

\begin{lstlisting}
	fun VideoPlayer(videoId : Int) {
		val context = LocalContext.current
		
		val exoPlayer = remember(context) {
			ExoPlayer.Builder(context).build().apply {
				val dataSourceFactory: DataSource.Factory = DefaultDataSource.Factory(context, DefaultHttpDataSource.Factory())
				val uriSource = Uri.parse(
				"android.resource://"
				+ context.packageName + "/" + videoId)
				val source = ProgressiveMediaSource.Factory(dataSourceFactory)
				.createMediaSource(
				MediaItem.fromUri(uriSource))
				this.setMediaSource(source)
				this.prepare()
			}
		}
		
		
		AndroidView(
		factory = { ctxt ->
			PlayerView(ctxt).apply {
				player = exoPlayer
				layoutParams = ViewGroup.LayoutParams(
				ViewGroup.LayoutParams.MATCH_PARENT,
				ViewGroup.LayoutParams.WRAP_CONTENT
				)
			}
		},
		update = { pview ->
			pview.apply {
				val player = this.player!!
				val uriSource = Uri.parse(
				"android.resource://"
				+ context.packageName + "/" + videoId)
				player.setMediaItem(MediaItem.fromUri(uriSource))
				player.prepare()
				//player.playWhenReady = true
				
			}
		},
		onReset = { pview ->
			pview.player = null
		}
		)
\end{lstlisting}

The composable function receives as parameter the videoId and initializes the player with the video defined by this id. 

To define the layout of the video buttons which allow navigating to different tutorial videos I am using at first a helper function which defines the VideoButton.

\begin{lstlisting}
	fun VideoButton(entry: VideoModel, currentVideoState: MutableState<Int>, modifier: Modifier) {
		Card(
		modifier.padding(1.dp).clickable {
			currentVideoState.value = entry.getVideoId()
		}.wrapContentHeight(),
		shape = RectangleShape,
		colors = CardDefaults.cardColors(
		containerColor = MaterialTheme.colorScheme.surfaceVariant
		)
		) {
			Column(
			verticalArrangement = Arrangement.Center,
			horizontalAlignment = Alignment.CenterHorizontally,
			modifier = Modifier.fillMaxSize()
			) {
				Text(
				modifier = Modifier.align(Alignment.CenterHorizontally),
				text = entry.getVideoName()
				)
			}
		}
	}
\end{lstlisting}

Then the layout of these buttons is defined with the composable LazyVerticalGrid, for portrait orientation, and with the composable LazyColumn, for landscape orientation.

\begin{lstlisting}
fun VideoScreen(modifier: Modifier, currentScreenState: MutableState<String>,
navController: NavController, videoModelList: List<VideoModel>) {
	
	currentScreenState.value = PlanesScreens.Tutorials.name
	val configuration = LocalConfiguration.current
	val currentVideoState = remember {
		mutableStateOf(R.raw.guessing)
	}
	
	Column(
	modifier = modifier,
	verticalArrangement = Arrangement.Center,
	horizontalAlignment = Alignment.CenterHorizontally
	) {
	when (configuration.orientation) {
		Configuration.ORIENTATION_PORTRAIT -> {
			
		Column(verticalArrangement = Arrangement.spacedBy(1.dp)) {
			VideoPlayer(currentVideoState.value)
			LazyVerticalGrid(
			columns = GridCells.Fixed(2),
			verticalArrangement = Arrangement.spacedBy(1.dp),
			horizontalArrangement = Arrangement.spacedBy(1.dp),
			contentPadding = PaddingValues(1.dp)
			) {
				items(items = videoModelList) { entry ->
					VideoButton(entry, currentVideoState, Modifier.width(200.dp).height(100.dp))
				}
			}
		}
		}
		else -> {
			Row() {
			Column(verticalArrangement = Arrangement.spacedBy(1.dp)) {
				Spacer(modifier = Modifier)
				LazyColumn(
				verticalArrangement = Arrangement.spacedBy(1.dp),
				contentPadding = PaddingValues(
				top = 1.dp,
				bottom = 1.dp
				)
				) {
					items(items = videoModelList) { entry ->
						VideoButton(entry, currentVideoState, Modifier.width(200.dp).height(100.dp))
					}
				}
			}
			
			VideoPlayer(currentVideoState.value)
			}
		}
	}
}
}
\end{lstlisting}

\subsection{Preferences Screen}

The preferences screen is defined as a composable function which takes a view model (optionsViewModel) as parameter:

\begin{lstlisting}
	
	fun PreferencesScreen(modifier: Modifier,
	currentScreenState: MutableState<String>,
	navController: NavController,
	optionsViewModel: PreferencesViewModel
	) {
		
		
		currentScreenState.value = PlanesScreens.Preferences.name
		val scrollState = rememberScrollState()
		
		val keyboardController = LocalSoftwareKeyboardController.current
		
		Column(modifier = modifier.fillMaxSize().padding(start = 15.dp).
		verticalScroll(state = scrollState),
		verticalArrangement = Arrangement.Top,
		horizontalAlignment = Alignment.Start) {
			
			val computerSkillsArray = stringArrayResource(R.array.computer_skills)
			
			Column(modifier = Modifier.padding(start = 15.dp, top = 10.dp))  {
				
				Text(text = stringResource(R.string.computer_skill),
				modifier = Modifier.padding(start = 15.dp))
				
				CheckBoxOption(text = computerSkillsArray[0],
				optionsViewModel.getComputerSkill() == 0,
				{optionsViewModel.setComputerSkill(0)})
				CheckBoxOption(text = computerSkillsArray[1],
				optionsViewModel.getComputerSkill() == 1,
				{optionsViewModel.setComputerSkill(1)})
				CheckBoxOption(text = computerSkillsArray[2],
				optionsViewModel.getComputerSkill() == 2,
				{optionsViewModel.setComputerSkill(2)})
				
			}
			
			
			val yesNoOptionsArray = stringArrayResource(R.array.yesno_options)
			Column(modifier = Modifier.padding(start = 15.dp, top = 10.dp)) {
				
				Text(text = stringResource(R.string.show_plane_after_kill),
				modifier = Modifier.padding(start = 15.dp))
				
				CheckBoxOption(text = yesNoOptionsArray[0],
				optionsViewModel.getShowPlaneAfterKill(),
				{optionsViewModel.setShowPlaneAfterKill(true)})
				CheckBoxOption(text = yesNoOptionsArray[1],
				!optionsViewModel.getShowPlaneAfterKill(),
				{optionsViewModel.setShowPlaneAfterKill(false)})
				
			}
			
			
			CommonTextField(modifier = Modifier.padding(15.dp),
			optionsViewModel,
			{ prefs ->  prefs.getUserName()},
			{ prefs, str -> prefs.setUserName(str)},
			onAction = KeyboardActions {
				keyboardController?.hide()
			},
			keyboardType = KeyboardType.Text,
			imeAction = ImeAction.Default,
			placeholder = stringResource(R.string.username))
			
			
			
			CommonTextField(
			modifier = Modifier.padding(15.dp),
			optionsViewModel,
			{ prefs -> prefs.getPassword() },
			{ prefs, str -> prefs.setPassword(str) },
			onAction = KeyboardActions {
				keyboardController?.hide()
			},
			keyboardType = KeyboardType.Text,
			imeAction = ImeAction.Default,
			placeholder = stringResource(R.string.password)
			)
			
		}
\end{lstlisting}

The persistence of the preferences is implemented inside the view model class:

\begin{lstlisting}
class PreferencesViewModel @Inject constructor(
private val dataStore: DataStore<Preferences>
): ViewModel() {
	
	private companion object {
		val COMPUTER_SKILL = intPreferencesKey("computer_skill")
		val SHOW_PLANE = booleanPreferencesKey("show_plane")
		val USERNAME = stringPreferencesKey("username")
		val PASSWORD = stringPreferencesKey("password")
	}
	
	private var m_ComputerSkill = mutableStateOf(2)
	private var m_ShowPlaneAfterKill = mutableStateOf(false)
	private var m_UserName = mutableStateOf("")
	private var m_Password = mutableStateOf("")
	
	fun getComputerSkill(): Int {
		return m_ComputerSkill.value
	}
	
	fun setComputerSkill(value: Int) {
		m_ComputerSkill.value = value
		
		viewModelScope.launch {
			dataStore.edit { prefs ->
				prefs[COMPUTER_SKILL] = value
			}
		}
	}
	
	fun getShowPlaneAfterKill() : Boolean {
		return m_ShowPlaneAfterKill.value
	}
	
	fun setShowPlaneAfterKill(value: Boolean) {
		m_ShowPlaneAfterKill.value = value
		
		viewModelScope.launch {
			dataStore.edit { prefs ->
				prefs[SHOW_PLANE] = value
			}
		}
	}
	
	fun getUserName(): String {
		return m_UserName.value
	}
	
	fun setUserName(value: String) {
		m_UserName.value = value
		
		viewModelScope.launch {
			dataStore.edit { prefs ->
				prefs[USERNAME] = value
			}
		}
	}
	
	fun getPassword(): String {
		return m_Password.value
	}
	
	fun setPassword(value: String) {
		m_Password.value = value
		
		viewModelScope.launch {
			dataStore.edit { prefs ->
				prefs[PASSWORD] = value
			}
		}
	}
	
	
	init {
		updateFields()
	}
	
	private fun updateFields() {
		viewModelScope.launch {
			dataStore.data.map { prefs ->
				UserPreferences(
				computerSkill = prefs[COMPUTER_SKILL] ?: 2,
				showPlaneAfterKill = prefs[SHOW_PLANE] ?: false,
				userName = prefs[USERNAME] ?: "",
				password = prefs[PASSWORD] ?: "")
				
			}.collect { userprefs ->
				
				m_ComputerSkill.value = userprefs.computerSkill
				m_ShowPlaneAfterKill.value = userprefs.showPlaneAfterKill
				m_UserName.value = userprefs.userName
				m_Password.value = userprefs.password
			}
			
		}
	}
	
	fun savePreferences() {
		viewModelScope.launch {
			dataStore.edit { prefs ->
				prefs[COMPUTER_SKILL] = m_ComputerSkill.value
				prefs[SHOW_PLANE] = m_ShowPlaneAfterKill.value
				prefs[USERNAME] = m_UserName.value
				prefs[PASSWORD] = m_Password.value
			}
		}
	}
	
}
\end{lstlisting}

This view model is not a simple data class like the implementation in \ref{pref_view_model1}. It derives from ViewModel and it is injected into the composables with dependency injection. It keeps its state when screen orientation is changed for example. 

The view model is connected to the composable (PreferencesScreen) defining the preference screen where it is given as parameter (optionsViewModel). In order for it to work smoothly with input methods like typing of username and password, it keeps the preferences elements into MutableState variables. MutableState variables are state holding variables whose change can be tracked by JetPack Compose. When the value change occurs some composable functions will be recomputed to update the interface.

In addition to saving inputs into the MutableState variables, they are persisted into a Data Store that is meant to keep the settings beyond stopping of the app. The data store is a newer alternative to the shared preferences used in \ref{pres_prefs1}

This is implemented for example in this method:

\begin{lstlisting}
	fun setShowPlaneAfterKill(value: Boolean) {
		m_ShowPlaneAfterKill.value = value
		
		viewModelScope.launch {
			dataStore.edit { prefs ->
				prefs[SHOW_PLANE] = value
			}
		}
	}
\end{lstlisting}

m\_ShowPlaneAfterKill is a MutableState variable which keeps the user option during the functioning of the application. Every time the user changes these options, this change is persisted through a coroutine (a kind of lightweight background job) to the data store. When the preferences value are required in the Preferences Screen they are delivered directly from the MutableState variables.

When the view model is first instantiated the values from the data store are read into the MutableState variables:

\begin{lstlisting}
	private fun updateFields() {
		viewModelScope.launch {
			dataStore.data.map { prefs ->
				UserPreferences(
				computerSkill = prefs[COMPUTER_SKILL] ?: 2,
				showPlaneAfterKill = prefs[SHOW_PLANE] ?: false,
				userName = prefs[USERNAME] ?: "",
				password = prefs[PASSWORD] ?: "")
			}.collect { userprefs ->
				m_ComputerSkill.value = userprefs.computerSkill
				m_ShowPlaneAfterKill.value = userprefs.showPlaneAfterKill
				m_UserName.value = userprefs.userName
				m_Password.value = userprefs.password
			}	
		}
	}
\end{lstlisting}

\subsection {Game Screen}

The game against the computer was refactored following clean code rules into three screens: board editing, game, and new game start. Whereas in the PlanesAndroid app the graphics were implemented in a monolith custom layout, in this version we use three screens. The game controls are implemented in Jetpack Compose directly, no custom layout is necessary. I am giving below the example of the board editing screen in the portrait screen orientation:

\begin{lstlisting}
Column(modifier = Modifier.height(screenHeightDp.dp - boardSizeDp.dp),
	verticalArrangement = Arrangement.Center) {
		Row(
		horizontalArrangement = Arrangement.Center,
		modifier = Modifier.height(buttonHeightDp.dp).fillMaxWidth()
		) {
			OneLineGameButton(
			textLine = stringResource(R.string.rotate_button), playerGridViewModel,
			modifier = Modifier.width(buttonWidthDp.dp).height(buttonHeightDp.dp),
			enabled = true
			) { viewModel ->
				viewModel.rotatePlane(playerGridViewModel.getSelectedPlane())
			}
			OneLineGameButton(
			textLine = stringResource(R.string.done_button), playerGridViewModel,
			modifier = Modifier.width(buttonWidthDp.dp).height(buttonHeightDp.dp),
			enabled = !playerGridViewModel.isPlaneOutsideGrid() && !playerGridViewModel.doPlanesOverlap()
			) {
				playerGridViewModel.updatePlanesToPlaneRound()
				playerGridViewModel.doneEditing()
				navController.popBackStack()
				navController.navigate(route = PlanesScreens.SinglePlayerGame.name)
			}
		}
		
		Row(
		horizontalArrangement = Arrangement.Center,
		modifier = Modifier.height(buttonHeightDp.dp).fillMaxWidth()
		) {
			OneLineGameButton(
			textLine = stringResource(R.string.cancel), playerGridViewModel,
			modifier = Modifier.width(buttonWidthDp.dp).height(buttonHeightDp.dp),
			enabled = true
			) {
				planeRound.cancelRound()
				navController.popBackStack()
				navController.navigate(route = PlanesScreens.SinglePlayerGameNotStarted.name)
			}
			TwoLineGameButton(
			textLine1 = stringResource(R.string.reset_board1),
			textLine2 = stringResource(R.string.reset_board2),
			playerGridViewModel,
			modifier = Modifier.width(buttonWidthDp.dp).height(buttonHeightDp.dp),
			enabled = true
			) { viewModel ->
				viewModel.initGrid()
			}
		}
	}
	
\end{lstlisting}

The game board uses a custom layout as defined in section \ref{custom_layouts_compose}. The code to display is as follows (for the game not started screen):

\begin{lstlisting}
	GameBoardSinglePlayer(gameBoardViewModel.getRowNo(), gameBoardViewModel.getColNo(),
	modifier = Modifier.padding(top = topBarHeight.value.dp)
	.width(boardSizeDp.dp).height(boardSizeDp.dp)) {
		for (index in 0..99)
		BoardSquareGameNotStarted(index, squareSizeDp, squareSizePx, gameBoardViewModel)
	}
\end{lstlisting}

The function to display the single cell depending on the piece it contains and on which guess was made is as follows:

\begin{lstlisting}
	@Composable
	fun BoardSquareGameNotStarted(index: Int, squareSizeDp: Int, squareSizePx: Float,
	planesGridViewModel: PlaneGridViewModel) {
		val row = index / planesGridViewModel.getColNo()
		val col = index % planesGridViewModel.getColNo()
		
		val pointOnPlane = planesGridViewModel.isPointOnPlane(col, row)
		
		val guess = planesGridViewModel.getGuessAtPosition(col, row)
		
		if (!pointOnPlane.first)
		GridSquareGameNotStarted(
		isComputer = planesGridViewModel.isComputer(),
		annotation = 0,
		guess = guess,
		widthDp = squareSizeDp,
		widthPx = squareSizePx,
		backgroundColor = Color.White,
		index = index
		)
		else {
			val annotation = planesGridViewModel.getAnnotation(pointOnPlane.second)
			val planesIdx = planesGridViewModel.decodeAnnotation(annotation)
			
			if (planesIdx.size == 1) {
				GridSquareGameNotStarted(
				isComputer = planesGridViewModel.isComputer(),
				annotation = if (planesIdx[0] < 0) -2 else planesIdx[0] + 1,
				guess = guess,
				widthDp = squareSizeDp,
				widthPx = squareSizePx,
				backgroundColor = Color.Blue,
				index = index
				)
				//Log.d("Planes", "plane ${planesIdx[0]}")
			} else {
				GridSquareGameNotStarted(
				isComputer = planesGridViewModel.isComputer(),
				annotation = -1,
				guess = guess,
				widthDp = squareSizeDp,
				widthPx = squareSizePx,
				backgroundColor = Color.Blue,
				index = index
				)
			}
		}
	}
\end{lstlisting}

\subsection{Login Screen}

The Login screen is a simple screen with two fields: one for the username and one for the password, together with a submit button. This is the same as in the PlanesAndroid, Retrofit is still being used, but this time instead of RxJava coroutine calls in the ViewModel are used.

\begin{lstlisting}
fun login() {
	viewModelScope.launch {
		m_Loading.value = true
		m_Error.value = null
		val result = withContext(Dispatchers.IO) {
			repository.login(getUserName(), getPassword())
		}
		
		if (result.data == null) {
			Log.d("PlanesCompose", "Login error ${result.e}")
			m_Error.value = result.e
		} else {
			m_LoggedInUserId.value = result.data?.m_Id
			m_LoggedInUsername.value = result.data?.m_Username
			m_LoggedInToken.value = result.data?.m_Authorization
			
			Log.d("PlanesCompose", "Login successfull with id ${getLoggedInUserId()}, username ${getLoggedInUserName()} and token ${getLoggedInToken()}")
		}
		m_Loading.value = result.loading!!
	}
}
\end{lstlisting} 

There is no need to define callback methods anymore, everything is done in the coroutine call. 

\subsection { Android Concepts }

\subsubsection { Composable Functions }
\subsubsection { Coroutines }

\subsubsection {Custom layouts} \label{custom_layouts_compose}

In the PlanesCompose App we use a custom layout for displaying the game board. Essential for defining a custom layout is defining a so-called MeasurePolicy. This defines the space allocated to the children of the layout as well as their position inside the layout. Here below is the concrete implementation of the GameBoardSinglePlayer. It is only a call to the Layout composable with three parameters: modifier, content and measurePolicy. 
The gameBoardSinglePlayerMeasurePolicy defines how the layout children are placed in the layout. It receives a list of measurables and constraints, calls the function measure on each measurable to calculate the maximum size it is allowed to have, then calls the function layout to place the measurables (children) in the layout.  

\begin{lstlisting}
	@Composable
	fun GameBoardSinglePlayer(rows: Int, cols: Int, modifier: Modifier = Modifier,
	content: @Composable () -> Unit) {
		Layout(
		modifier = modifier,
		content = content,
		measurePolicy = gameBoardSinglePlayerMeasurePolicy(rows, cols)
		)
	}
	
	fun gameBoardSinglePlayerMeasurePolicy(rows: Int, cols: Int): MeasurePolicy =
	MeasurePolicy { measurables, constraints ->
		val placeables = measurables.map { measurable ->
			measurable.measure(constraints.copy(
			maxWidth = constraints.maxWidth / cols,
			maxHeight = constraints.maxHeight / rows,
			minWidth = constraints.maxWidth / cols,
			minHeight = constraints.maxHeight / rows))
		}
		
		
		layout(constraints.maxWidth, constraints.maxHeight) {
			var yPos = 0
			var xPos = 0
			var maxY = 0
			
			placeables.forEachIndexed { index, placeable ->
				//if (xPos + placeable.width >= constraints.maxWidth) {
					if (index % cols == 0) {
						xPos = 0
						yPos += maxY
						maxY = 0
					}
					
					placeable.placeRelative(
					x = xPos,
					y = yPos
					)
					
					xPos += placeable.width
					
					if (maxY < placeable.height) {
						maxY = placeable.height
					}
				}
			}
		}
	\end{lstlisting}